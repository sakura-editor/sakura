/*!	@file

	@author Project Sakura-Editor
	@date 2007.09.30 kobake 作成
	@date 2009.07.06 rastiv #pragma once を除去して #ifndef-#endif 文に変更
*/
/*
	Copyright (C) 2007-2008, kobake
	Copyright (C) 2009, rastiv
	Copyright (C) 2018-2022, Sakura Editor Organization

	This software is provided 'as-is', without any express or implied
	warranty. In no event will the authors be held liable for any damages
	arising from the use of this software.

	Permission is granted to anyone to use this software for any purpose,
	including commercial applications, and to alter it and redistribute it
	freely, subject to the following restrictions:

		1. The origin of this software must not be misrepresented;
		   you must not claim that you wrote the original software.
		   If you use this software in a product, an acknowledgment
		   in the product documentation would be appreciated but is
		   not required.

		2. Altered source versions must be plainly marked as such,
		   and must not be misrepresented as being the original software.

		3. This notice may not be removed or altered from any source
		   distribution.
*/

/*
	++ 概要 ++

	enum と define の2種類の定数定義ヘッダを生成するためのモノ

	enum定数はソースコードから参照し、(デバッグがしやすくなる)
	define定数はリソースから参照する  (リソース内ではenum定数を利用できない)

	++ 依存 ++

	Visual Studio の cl.exe に依存。
	cl.exe のプリプロセッサ機能を利用しています。

	++ 使用方法 ++

	usage() を参照
*/

#include <cstring>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <memory>
#include <string>
#include <string_view>

#ifdef _MSC_VER
#define PREPROCESSOR "cl.exe /nologo /source-charset:utf-8 /execution-charset:shift_jis /EP %s"
#elif defined(__GNUC__)
#define PREPROCESSOR "gcc.exe -x c++ -finput-charset=utf-8 -fexec-charset=cp932 -E %s"
#endif	// _MSC_VER

enum class EMode {
	Invalid,

	Enum,
	Define,
};

int usage()
{
	std::cout << std::endl
		<< "Usage: HeaderMake -in=<InputFile.hsrc> -out=<OutputFile.h> -mode=<Mode> [-enum=<EnumName>]" << std::endl
		<< std::endl
		<< "  Argument parameters" << std::endl
		<< "    InputFile           : Input .hsrc file path" << std::endl
		<< "    OutputFile          : Output .h file path" << std::endl
		<< "    Mode                : define|enum" << std::endl
		<< "    EnumName (Optional) : Enum name (when enum mode only)" << std::endl
		<< std::endl
		<< "  Mode" << std::endl
		<< "    define : Output .h file as #define list" << std::endl
		<< "    enum   : Output .h file as enum list" << std::endl;
	return 1;
}

inline bool is_token(char c)
{
	return __iscsym(c) || c=='-';
}

inline std::string_view get_token(const char*& p)
{
	if (!p) {
		throw std::invalid_argument("p can't be nullptr");
	}

	while (*p && !is_token(*p))p++;

	const char* q = p;
	while (*q && is_token(*q))q++;

	auto ret = std::string_view(p, q - p);
	p = q;

	return ret;
}

class CHeaderMake
{
protected:
	[[nodiscard]] virtual const char* GetSymbolName() const;

	virtual void OutputHeader(std::filesystem::path in_file, std::ostream& out) const;
	virtual void OutputValue(std::ostream& out, std::string_view id, std::string_view value) const;
	virtual void OutputFooter(std::ostream& out) const;

public:
	static std::unique_ptr<CHeaderMake> CreateInstance(EMode mode, std::string_view enumName);

	int DoMain(const char* in_file, std::filesystem::path out_file) const;
};

class CResourceHeaderMake : public CHeaderMake
{
};

class CCppSourceHeaderMake : public CHeaderMake
{
private:
	std::string		enumName;

protected:
	[[nodiscard]] const char* GetSymbolName() const override;

	void OutputHeader(std::filesystem::path in_file, std::ostream& out) const override;
	void OutputValue(std::ostream& out, std::string_view id, std::string_view value) const override;
	void OutputFooter(std::ostream& out) const override;

public:
	explicit CCppSourceHeaderMake(std::string_view enumName);
};

[[nodiscard]] const char* CHeaderMake::GetSymbolName() const
{
	return "SAKURA_HEADERMAKE_98B26AB2_D5C9_4884_8D15_D1F3A2936253_H_";
}

void CHeaderMake::OutputHeader(std::filesystem::path in_file, std::ostream& out) const
{
	out << "/*! @file */" << std::endl;

	// インクルードガード開始
	out
		<< "#ifndef " << GetSymbolName() << std::endl
		<< "#define " << GetSymbolName() << std::endl
		<< std::endl;

	out
		<< "// This file is generated by HeaderMake with " << in_file.filename().string() << "." << std::endl
		<< "// Don't edit this file manually." << std::endl
		<< std::endl;
}

void CHeaderMake::OutputValue(std::ostream& out, std::string_view id, std::string_view value) const
{
	out << "#define " << id << " " << value << std::endl;
}

void CHeaderMake::OutputFooter(std::ostream& out) const
{
	// インクルードガード終了
	out << std::endl
		<< "#endif /* " << GetSymbolName() << " */" << std::endl;
}

int CHeaderMake::DoMain(const char* in_file, std::filesystem::path out_file) const
{
	// プリプロセス済みストリームオープン
	char cmdline[_MAX_PATH + _countof(PREPROCESSOR)];
	::sprintf_s(cmdline, _countof(cmdline), PREPROCESSOR, in_file);
	FILE* in = ::_popen(cmdline, "rt");
	if (!in) {
		std::cerr << "Error: Failed to open process[" << cmdline << "]" << std::endl;
		return 1;
	}

	// 出力ファイルオープン
	std::ofstream out(out_file);
	if (!out) {
		std::cerr << "Error: Failed to open OutputFile[" << out_file << "] as write mode" << std::endl;
		return 1;
	}

	// ヘッダーを出力する
	OutputHeader(in_file, out);

	//処理
	char line[1024];
	while (NULL != ::fgets(line, _countof(line), in))
	{
		// #無視(for MinGW)
		if ('#' == line[0]) {
			continue;
		}

		//改行除去
		if (char* p = ::strrchr(line, '\n');
			p && p[1] == '\0')
		{
			*p = '\0';
		}

		//トークン抽出開始
		const char* p = line;

		//ID文字列 -> id
		const auto id = get_token(p);

		if (id.empty()) {
			continue;
		}

		//値 -> value
		const auto value = get_token(p);;

		if (value.empty()) {
			continue;
		}

		//出力
		OutputValue(out, id, value);
	}

	// フッターを出力する
	OutputFooter(out);

	//後始末
	out.close();
	fclose(in);

	return 0;
}

CCppSourceHeaderMake::CCppSourceHeaderMake(std::string_view enumName)
	: enumName(enumName)
{
}

[[nodiscard]] const char* CCppSourceHeaderMake::GetSymbolName() const
{
	return "SAKURA_HEADERMAKE_2034D8F5_AE65_408D_9F53_D3DEA240C67BI_H_";
}

void CCppSourceHeaderMake::OutputHeader(std::filesystem::path in_file, std::ostream& out) const
{
	// 共通のヘッダーを出力する
	CHeaderMake::OutputHeader(in_file, out);

	// Enum版独自の追加ヘッダーを出力する
	out << "enum " << enumName << "{" << std::endl; //enum開始
}

void CCppSourceHeaderMake::OutputValue(std::ostream& out, std::string_view id, std::string_view value) const
{
	out << "\t" << id << " = " << value << "," << std::endl;
}

void CCppSourceHeaderMake::OutputFooter(std::ostream& out) const
{
	// Enum版独自の追加フッターを出力する
	out << "};" << std::endl; //enum終了

	// 共通のフッターを出力する
	CHeaderMake::OutputFooter(out);
}

std::unique_ptr<CHeaderMake> CHeaderMake::CreateInstance(EMode mode, std::string_view enumName)
{
	if (mode == EMode::Enum) {
		return std::unique_ptr<CHeaderMake>(new CCppSourceHeaderMake(enumName));
	}
	if (mode == EMode::Define) {
		return std::unique_ptr<CHeaderMake>(new CResourceHeaderMake());
	}
	return std::unique_ptr<CHeaderMake>();
}

int main(int argc, char* argv[])
{
	if (argc <= 1) {
		return usage();
	}

	//引数解釈
	const char* in_file = NULL;
	const char* out_file = NULL;
	const char* mode_name = NULL;
	const char* enum_name = "";
	for (int i = 1; i<argc; i++) {
		char* p = argv[i];
		if (*p == '/')*p = '-';
		if (strncmp(p, "-in", 3) == 0) {
			p += 3;
			if (*p != '\0') { if (*p == '=')p++; in_file = p; }
			else in_file = argv[++i];
		}
		else if (strncmp(p, "-out", 4) == 0) {
			p += 4;
			if (*p != '\0') { if (*p == '=')p++; out_file = p; }
			else out_file = argv[++i];
		}
		else if (strncmp(p, "-mode", 5) == 0) {
			p += 5;
			if (*p != '\0') { if (*p == '=')p++; mode_name = p; }
			else mode_name = argv[++i];
		}
		else if (strncmp(p, "-enum", 5) == 0) {
			p += 5;
			if (*p != '\0') { if (*p == '=')p++; enum_name = p; }
			else enum_name = argv[++i];
		}
		else {
			std::cerr << "Error: Unknown argument[" << p << "]" << std::endl;
			return 1;
		}
	}
	if (!in_file)   { std::cerr << "Error: Specify <InputFile> argument." << std::endl;  return usage(); }
	if (!out_file)  { std::cerr << "Error: Specify <OutputFile> argument." << std::endl; return usage(); }
	if (!mode_name) { std::cerr << "Error: Specify <Mode> argument." << std::endl;       return usage(); }

	//モード解釈
	EMode mode = EMode::Invalid;
	if (::_stricmp(mode_name, "DEFINE") == 0) mode = EMode::Define;
	else if (::_stricmp(mode_name, "ENUM") == 0) mode = EMode::Enum;

	const auto headerMake = CHeaderMake::CreateInstance(mode, enum_name);
	if (!headerMake)
	{
		std::cerr << "Error: Unknown mode[" << mode_name << "]" << std::endl;
		return usage();;
	}

	// 入力ファイルの存在チェック
	if (std::error_code ec;
		!std::filesystem::exists(in_file, ec))
	{
		std::cerr << "Error: InputFile must exists." << std::endl;
		return usage();
	}

	// 開始メッセージ
	std::cout << std::endl
		<< "START HeaderMake." << std::endl
		<< "CMDLINE: ";
	for (int i = 0; i < argc; i++) {
		const auto arg = argv[i];
		std::cout << arg << " ";
	}
	std::cout << std::endl << std::endl;

	// 処理
	headerMake->DoMain(in_file, out_file);

	// 終了メッセージ
	std::cout << std::endl
		<< "END HeaderMake." << std::endl
		<< std::endl;
}
